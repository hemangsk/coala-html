{
  "/Users/Hemang/Desktop/final/automata-python/automata/data_structures/stack.py": [
    "class Stack:\n",
    "\n",
    "    def __init__(self):\n",
    "        self.stack = []\n",
    "\n",
    "    def push(self, item):\n",
    "        self.stack.append((item))\n",
    "\n",
    "    def pop(self):\n",
    "        return self.stack.pop()\n",
    "\n",
    "    def isEmpty(self):\n",
    "        return self.stack == []\n",
    "\n",
    "    def size(self):\n",
    "        return len(self.stack)\n",
    "\n",
    "    def top(self):\n",
    "        return self.stack[self.size() - 1]\n",
    "\n",
    "    def __contains__(self, item):\n",
    "        for x in self.stack:\n",
    "            #print (\"in Stack\" + str(x))\n",
    "            if x == item:\n",
    "                return True\n",
    "\n",
    "        return False\n",
    "\n",
    "\n",
    "    def __str__(self):\n",
    "        output = \"[  \"\n",
    "        for x in self.stack:\n",
    "            output += str(x)\n",
    "            output += \", \"\n",
    "\n",
    "        return output[:-2] + \" ]\""
  ],
  "/Users/Hemang/Desktop/final/automata-python/automata/fa/DFA.py": [
    "# -*- coding: utf-8 -*-\n",
    "\n",
    "\n",
    "class DFA(object):\n",
    "    \"\"\"Deterministic Finite Automata\"\"\"\n",
    "\n",
    "    def __init__(self, states, alphabet, transitions, initial_state, final_states):\n",
    "        \"\"\"\n",
    "        Q is a finite set of states.\n",
    "\n",
    "        sigma is a finite set of symbols called the alphabet.\n",
    "\n",
    "        delta is the list of transitions based on transition relation.\n",
    "\n",
    "        q0 is the initial state from where any input is processed (q0 \u2208 Q).\n",
    "\n",
    "        F is a set of final state/states of Q (F \u2286 Q).\n",
    "        \"\"\"\n",
    "\n",
    "        self.states = states                        #list\n",
    "        self.alphabet = alphabet                    #list\n",
    "        self.transitions = transitions              #dict\n",
    "        self.initial_state = initial_state          #char\n",
    "        self.final_states = final_states            #list\n",
    "\n",
    "        \"\"\"\n",
    "        states=['q0', 'q1'],\n",
    "        alphabets=['a', 'b'],\n",
    "        transitions={\n",
    "            'q0': {'a': 'q0', 'b': 'q1'},\n",
    "            'q1': {'a': 'q0', 'b': 'q1'},\n",
    "         },\n",
    "        initial_state='q0',\n",
    "        final_states=['q1']\n",
    "        \"\"\"\n",
    "\n",
    "    def is_string_valid(self, string):\n",
    "        \"\"\"Return True if string is accepted by DFA, otherwise return False\"\"\"\n",
    "\n",
    "        inputs = list(string)\n",
    "        current_state = self.initial_state\n",
    "\n",
    "        for letter in inputs:\n",
    "            try:\n",
    "\n",
    "                if letter in self.transitions[current_state]:\n",
    "                    current_state = self.transitions[current_state][letter]\n",
    "\n",
    "                else:\n",
    "                    return False\n",
    "            except KeyError as e:\n",
    "                return False\n",
    "\n",
    "        if current_state in self.final_states:\n",
    "            return True\n",
    "\n",
    "        return False\n",
    "\n",
    "    def minimize(self):\n",
    "\n",
    "        state_list = [list(set(self.states) - set(self.final_states)), self.final_states]\n",
    "\n",
    "        foo_dict = {}\n",
    "        final_list = []\n",
    "\n",
    "        while(1):\n",
    "\n",
    "            if state_list == final_list :\n",
    "                break\n",
    "            final_list, foo_dict = self.create_foo_dict(state_list, foo_dict)\n",
    "            state_list = self.create_state_list(foo_dict)\n",
    "\n",
    "        new_states_dict = {}\n",
    "        minified_initial_state = ''\n",
    "        minified_states = []\n",
    "        minified_final_states = []\n",
    "        i = 0\n",
    "        for x in state_list:\n",
    "            for y in x:\n",
    "                string = 'P' + str(i)\n",
    "                new_states_dict[y] =  string\n",
    "                if y in self.final_states and string not in minified_final_states:\n",
    "                    minified_final_states.append(string)\n",
    "\n",
    "                if y == self.initial_state and minified_initial_state == '':\n",
    "                    minified_initial_state = string\n",
    "\n",
    "            if string not in minified_states:\n",
    "                minified_states.append(string)\n",
    "\n",
    "            i += 1\n",
    "\n",
    "        minified_transitions = {}\n",
    "        for x in self.alphabet:\n",
    "            for s in self.states:\n",
    "                try:\n",
    "                    minified_transitions[new_states_dict[s]][x] = new_states_dict[self.transitions[s][x]]\n",
    "                except KeyError as e:\n",
    "                    minified_transitions[new_states_dict[s]] = {}\n",
    "                    minified_transitions[new_states_dict[s]][x] = new_states_dict[self.transitions[s][x]]\n",
    "\n",
    "        minified_dfa = DFA(minified_states, self.alphabet, minified_transitions, minified_initial_state, minified_final_states)\n",
    "        print(minified_dfa)\n",
    "\n",
    "    def create_state_list(self, foo_dict):\n",
    "        temp_list = []\n",
    "        for x in foo_dict.keys():\n",
    "            temp_list.append(foo_dict[x])\n",
    "\n",
    "        temp_list_2 = []\n",
    "        for x in temp_list:\n",
    "            if x not in temp_list_2:\n",
    "                temp_list_2.append(x)\n",
    "\n",
    "        state_list = []\n",
    "\n",
    "        for x in temp_list_2:\n",
    "            state_list_element = []\n",
    "            for k,v in foo_dict.items():\n",
    "                if v == x:\n",
    "                    state_list_element.append(k)\n",
    "            state_list.append(state_list_element)\n",
    "\n",
    "        return state_list\n",
    "\n",
    "    def create_foo_dict(self, state_list, foo_dict):\n",
    "\n",
    "        for x in self.states:\n",
    "            for a in self.alphabet:\n",
    "                for y in state_list:\n",
    "                    if self.transitions[x][a] in y:\n",
    "                        try:\n",
    "                            foo_dict[x].append(state_list.index(y))\n",
    "                        except KeyError as e:\n",
    "                            foo_dict[x] = []\n",
    "                            foo_dict[x].append(state_list.index(y))\n",
    "\n",
    "        return state_list, foo_dict\n",
    "\n",
    "    def __str__(self):\n",
    "        \"\"\"\"Pretty Print the DFA\"\"\"\n",
    "\n",
    "        output = \"\\nDeterministic Finite Automata\" + \\\n",
    "                 \"\\nStates \" + str(self.states) + \\\n",
    "                 \"\\nAlphabet \" + str(self.alphabet) + \\\n",
    "                 \"\\nTransitions \" + str(self.transitions) + \\\n",
    "                 \"\\nInital State \" + str(self.initial_state) + \\\n",
    "                 \"\\nFinal States \" + str(self.final_states)\n",
    "\n",
    "        return output\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "d = DFA(\n",
    "['q0', 'q1', 'q2', 'q3', 'q4', 'q5', 'q6', 'q7', 'q8','q9','q10'],\n",
    "['a', 'b'],\n",
    "{\n",
    "\n",
    "    'q0': {'a': 'q3', 'b': 'q2'},\n",
    "    'q1': {'a': 'q6', 'b': 'q2'},\n",
    "    'q2': {'a': 'q8', 'b': 'q5'},\n",
    "    'q3': {'a': 'q0', 'b': 'q1'},\n",
    "    'q4': {'a': 'q2', 'b': 'q5'},\n",
    "    'q5': {'a': 'q4', 'b': 'q3'},\n",
    "    'q6': {'a': 'q1', 'b': 'q0'},\n",
    "    'q7': {'a': 'q4', 'b': 'q6'},\n",
    "    'q8': {'a': 'q2', 'b': 'q7'},\n",
    "    'q9': {'a': 'q7', 'b': 'q10'},\n",
    "    'q10': {'a': 'q5', 'b': 'q9'}\n",
    "\n",
    " },\n",
    "'q0',\n",
    "['q3', 'q4', 'q6','q8']\n",
    ")\n",
    "\n",
    "d.minimize()\n",
    "\"\"\"\n",
    "print(d.is_string_valid('ababba'))\n",
    "print(d.convert_to_dfa())\n",
    "print(d)\n",
    "\"\"\""
  ],
  "/Users/Hemang/Desktop/final/automata-python/automata/fa/Mealy.py": [
    "# -*- coding: utf-8 -*-\n",
    "\n",
    "\n",
    "\n",
    "class Mealy(object):\n",
    "    \"\"\"Mealy Machine : Finite Automata with Output \"\"\"\n",
    "\n",
    "    def __init__(self, states, input_alphabet, output_alphabet, transitions, initial_state):\n",
    "        \"\"\"\n",
    "        6 tuple (Q, \u2211, O, \u03b4, X, q0) where \u2212\n",
    "\n",
    "        states is a finite set of states.\n",
    "\n",
    "        alphabet is a finite set of symbols called the input alphabet.\n",
    "\n",
    "        output_alphabet is a finite set of symbols called the output alphabet.\n",
    "\n",
    "        transitions is the resultant data dictionary of input and output transition functions\n",
    "\n",
    "        initial_state is the initial state from where any input is processed (q0 \u2208 Q).\n",
    "        \"\"\"\n",
    "        self.states = states\n",
    "        self.input_alphabet = input_alphabet\n",
    "        self.output_alphabet = output_alphabet\n",
    "        self.transitions = transitions\n",
    "        self.initial_state = initial_state\n",
    "\n",
    "    def get_output_from_string(self, string):\n",
    "        \"\"\"Return Mealy Machine's output when a given string is given as input\"\"\"\n",
    "\n",
    "        temp_list = list(string)\n",
    "        current_state = self.initial_state\n",
    "        output = ''\n",
    "        for x in temp_list:\n",
    "            output+= self.transitions[current_state][x][1]\n",
    "            current_state = self.transitions[current_state][x][0]\n",
    "\n",
    "        return output\n",
    "\n",
    "    def convert_to_moore(self):\n",
    "        moore_transitions = {}\n",
    "        temp_list = []\n",
    "        moore_output_table = {}\n",
    "        moore_initial_state = self.initial_state\n",
    "        for x in self.transitions.keys():\n",
    "            for a in self.input_alphabet:\n",
    "                temp_list.append(self.transitions[x][a])\n",
    "\n",
    "        temp_list_2 = []\n",
    "        for x in temp_list:\n",
    "            for y in temp_list:\n",
    "                if x[0] == y[0] and x[1] != y[1]:\n",
    "                    if x not in temp_list_2 and y not in temp_list_2:\n",
    "                        temp_list_2.append(x)\n",
    "                        temp_list_2.append(y)\n",
    "\n",
    "        temp_list_3 = []\n",
    "        for x in temp_list_2:\n",
    "            if x[0] not in temp_list_3:\n",
    "                temp_list_3.append(x[0])\n",
    "\n",
    "        if self.initial_state in temp_list_3:\n",
    "            moore_initial_state = self.initial_state + self.output_alphabet[0]\n",
    "\n",
    "        for x in temp_list_2:\n",
    "            for a in self.input_alphabet:\n",
    "                if self.transitions[x[0]][a][0] in temp_list_3:\n",
    "                    next_state = self.transitions[x[0]][a][0]\n",
    "                    output = self.transitions[x[0]][a][1]\n",
    "\n",
    "                    next_state = next_state + output\n",
    "                    try:\n",
    "                        moore_transitions[x[0] + x[1]][a] = next_state\n",
    "                    except KeyError as e:\n",
    "                        moore_transitions[x[0] + x[1]] = {}\n",
    "                        moore_transitions[x[0] + x[1]][a] = next_state\n",
    "\n",
    "                    if next_state not in moore_output_table.keys():\n",
    "                        moore_output_table[next_state] = output\n",
    "\n",
    "                else:\n",
    "                    try:\n",
    "                        moore_transitions[x[0] + x[1]][a] = self.transitions[x[0]][a][0]\n",
    "                    except KeyError as e:\n",
    "                        moore_transitions[x[0] + x[1]] = {}\n",
    "                        moore_transitions[x[0] + x[1]][a] = self.transitions[x[0]][a][0]\n",
    "\n",
    "                    if moore_transitions[x[0] + x[1]][a] not in moore_output_table.keys():\n",
    "                        moore_output_table[moore_transitions[x[0] + x[1]][a]] = self.transitions[x[0]][a][1]\n",
    "\n",
    "        for x in self.transitions.keys():\n",
    "            if x not in moore_transitions.keys() and x not in temp_list_3:\n",
    "                for a in self.input_alphabet:\n",
    "                    if self.transitions[x][a][0] in temp_list_3:\n",
    "                        next_state = self.transitions[x][a][0]\n",
    "                        output = self.transitions[x][a][1]\n",
    "\n",
    "                        next_state = next_state + output\n",
    "                        try:\n",
    "                            moore_transitions[x][a] = next_state\n",
    "                        except KeyError as e:\n",
    "                            moore_transitions[x] = {}\n",
    "                            moore_transitions[x][a] = next_state\n",
    "\n",
    "                        if next_state not in moore_output_table.keys():\n",
    "                            moore_output_table[next_state] = output\n",
    "\n",
    "                    else:\n",
    "                        try:\n",
    "                            moore_transitions[x][a] = self.transitions[x][a][0]\n",
    "                        except KeyError as e:\n",
    "                            moore_transitions[x] = {}\n",
    "                            moore_transitions[x][a] = self.transitions[x][a][0]\n",
    "\n",
    "                        if self.transitions[x][a][0] not in moore_output_table.keys():\n",
    "                            moore_output_table[self.transitions[x][a][0]] = self.transitions[x][a][1]\n",
    "\n",
    "        moore_states = []\n",
    "        for s in moore_transitions.keys():\n",
    "            if s not in moore_states:\n",
    "                moore_states.append(s)\n",
    "\n",
    "        from automata.fa.Moore import Moore\n",
    "\n",
    "        moore_from_mealy = Moore(\n",
    "            moore_states,\n",
    "            self.input_alphabet,\n",
    "            self.output_alphabet,\n",
    "            moore_transitions,\n",
    "            moore_output_table,\n",
    "            moore_initial_state\n",
    "        )\n",
    "\n",
    "        print(moore_from_mealy)\n",
    "\n",
    "\n",
    "    def __str__(self):\n",
    "        output = \"\\nMealy Machine\" + \\\n",
    "                 \"\\nStates \" + str(self.states) + \\\n",
    "                 \"\\nTransitions \" + str(self.transitions) + \\\n",
    "                 \"\\nInital State \" + str(self.initial_state) + \\\n",
    "                 \"\\nInital Alphabet \" + str(self.input_alphabet) + \\\n",
    "                 \"\\nOutput Alphabet\" + str(self.output_alphabet)\n",
    "\n",
    "        return output\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "\"\"\"\n",
    "mealy = Mealy(\n",
    "    ['a', 'b', 'c', 'd'],\n",
    "    ['0', '1'],\n",
    "    ['0', '1'],\n",
    "    {\n",
    "        'a' : {\n",
    "            '0' : ('d', '1'),\n",
    "            '1' : ('b', '0')\n",
    "        },\n",
    "\n",
    "        'b' : {\n",
    "            '0' : ('a', '1'),\n",
    "            '1' : ('d', '1')\n",
    "        },\n",
    "\n",
    "        'c' :{\n",
    "            '0' : ('c', '0'),\n",
    "            '1' : ('c', '0')\n",
    "        },\n",
    "        'd':{\n",
    "            '0' : ('b', '0'),\n",
    "            '1' : ('a', '1')\n",
    "        }\n",
    "    },\n",
    "    'a'\n",
    ")\n",
    "\n",
    "\n",
    "mealy_2 = Mealy(['q0'],\n",
    "                ['0', '1'],\n",
    "                ['0', '1'],\n",
    "                {\n",
    "                    'q0' : {\n",
    "                        '1' : ('q0', '0'),\n",
    "                        '0' : ('q0', '1')\n",
    "                    }\n",
    "                },\n",
    "                'q0'\n",
    "                )\n",
    "\n",
    "mealy_3 = Mealy(['q0', 'q1', 'q2', 'q3'],\n",
    "                ['0', '1'],\n",
    "                ['0', '1'],\n",
    "                {\n",
    "                    'q0' : {\n",
    "                        '0' : ('q3', '0'),\n",
    "                        '1' : ('q1', '1')\n",
    "                    },\n",
    "                    'q1': {\n",
    "                        '0': ('q0', '1'),\n",
    "                        '1': ('q3', '0')\n",
    "                    },\n",
    "                    'q2': {\n",
    "                        '0': ('q2', '1'),\n",
    "                        '1': ('q2', '0')\n",
    "                    },\n",
    "                    'q3': {\n",
    "                        '0': ('q1', '0'),\n",
    "                        '1': ('q0', '1')\n",
    "                    }\n",
    "\n",
    "                },\n",
    "                'q0'\n",
    "\n",
    "                )\n",
    "#print(mealy_2)\n",
    "#print(mealy_2.get_output_from_string('0111'))\n",
    "print(mealy_3.convert_to_moore())\n",
    "\"\"\""
  ],
  "/Users/Hemang/Desktop/final/automata-python/automata/fa/Moore.py": [
    "# -*- coding: utf-8 -*-\n",
    "\n",
    "\n",
    "class Moore(object):\n",
    "    \"\"\"Moore Machine : Finite Automata with Output\"\"\"\n",
    "\n",
    "    def __init__(self, states, input_alphabet, output_alphabet, transitions, initial_state, output_table ):\n",
    "        \"\"\"\n",
    "        states: Finite set of states\n",
    "        input_alphabet: Alphabet of letters for forming input string\n",
    "        output_alphabet: Alphabet of letters for forming output characters\n",
    "        transitions: Transition Table\n",
    "        output_table: Output Table to show what character from output_alphabet is printed when a state from 'states'\n",
    "        is reached\n",
    "        \"\"\"\n",
    "\n",
    "        self.states = states\n",
    "        self.input_alphabet = input_alphabet\n",
    "        self.output_alphabet = output_alphabet\n",
    "        self.transitions = transitions\n",
    "        self.output_table = output_table\n",
    "        self.initial_state = initial_state\n",
    "\n",
    "    def get_output_from_string(self, string):\n",
    "        \"\"\"Return Moore Machine's output when a given string is given as input\"\"\"\n",
    "        temp_list = list(string)\n",
    "        output = ''\n",
    "        current_state = self.initial_state\n",
    "        output += self.output_table[current_state]\n",
    "        for x in temp_list:\n",
    "            current_state = self.transitions[current_state][x]\n",
    "            output += self.output_table[current_state]\n",
    "\n",
    "        return output\n",
    "\n",
    "    def convert_to_mealy(self):\n",
    "        mealy_transitions = {}\n",
    "\n",
    "        for x in self.transitions.keys():\n",
    "\n",
    "            try:\n",
    "                mealy_transitions[x] = {}\n",
    "\n",
    "                for  a in self.input_alphabet:\n",
    "                    mealy_transitions[x][a] = (self.transitions[x][a], self.output_table[self.transitions[x][a]])\n",
    "\n",
    "            except KeyError as e:\n",
    "                pass\n",
    "\n",
    "        mealy_input_alphabet = self.input_alphabet\n",
    "        mealy_output_alphabet = self.output_alphabet\n",
    "        mealy_initial_state = self.initial_state\n",
    "        mealy_states = self.states\n",
    "\n",
    "        #print(mealy_transitions)\n",
    "\n",
    "        from automata.fa.Mealy import Mealy\n",
    "\n",
    "        mealy_from_moore = Mealy(\n",
    "            mealy_states,\n",
    "            mealy_input_alphabet,\n",
    "            mealy_output_alphabet,\n",
    "            mealy_transitions,\n",
    "            mealy_initial_state\n",
    "        )\n",
    "\n",
    "        print(mealy_from_moore)\n",
    "\n",
    "    def __str__(self):\n",
    "        \"\"\"\"Pretty Print the Moore Machine\"\"\"\n",
    "\n",
    "        output = \"\\nMoore Machine\" + \\\n",
    "                 \"\\nStates \" + str(self.states) + \\\n",
    "                 \"\\nInput Alphabet \" + str(self.input_alphabet) + \\\n",
    "                 \"\\nOutput Alphabet \" + str(self.output_alphabet) + \\\n",
    "                 \"\\nTransitions \" + str(self.transitions) + \\\n",
    "                 \"\\nInitial State\" + str(self.initial_state) + \\\n",
    "                 \"\\nOutput Table \" + str(self.output_table)\n",
    "\n",
    "        return output\n",
    "\n",
    "\"\"\"\n",
    "moore = Moore(['q0', 'q1', 'q2', 'q3'],\n",
    "              ['a' , 'b'],\n",
    "              ['0', '1'],\n",
    "              {\n",
    "                  'q0' : {\n",
    "                      'a' : 'q1',\n",
    "                      'b' : 'q3'\n",
    "\n",
    "                  },\n",
    "                  'q1': {\n",
    "                      'a': 'q3',\n",
    "                      'b': 'q1'\n",
    "\n",
    "                  },\n",
    "                  'q2': {\n",
    "                      'a': 'q0',\n",
    "                      'b': 'q3'\n",
    "\n",
    "                  },\n",
    "                  'q3': {\n",
    "                      'a': 'q3',\n",
    "                      'b': 'q2'\n",
    "\n",
    "                  }\n",
    "\n",
    "\n",
    "              },\n",
    "\n",
    "              'q0',\n",
    "              {\n",
    "                  'q0' : '1',\n",
    "                  'q1' : '0',\n",
    "                  'q2' : '0',\n",
    "                  'q3' : '1'\n",
    "              }\n",
    "\n",
    "\n",
    "              )\n",
    "print(moore)\n",
    "print(moore.get_output_from_string('abbba'))\n",
    "print(moore.convert_to_mealy())\n",
    "\n",
    "\"\"\""
  ],
  "/Users/Hemang/Desktop/final/automata-python/automata/fa/NDFA.py": [
    "# -*- coding: utf-8 -*-\n",
    "from automata.data_structures.Stack import Stack\n",
    "from automata.fa.DFA import DFA\n",
    "\n",
    "\n",
    "class NDFA(object):\n",
    "    \"\"\"Non Deterministic Finite Automata\"\"\"\n",
    "\n",
    "    def __init__(self, states, alphabet, transitions, initial_state, final_states):\n",
    "        \"\"\"\n",
    "        Q is a finite set of states.\n",
    "\n",
    "        sigma is a finite set of symbols called the alphabet.\n",
    "\n",
    "        delta is the list of transitions based on transition relation.\n",
    "\n",
    "        q0 is the initial state from where any input is processed (q0 \u2208 Q).\n",
    "\n",
    "        F is a set of final state/states of Q (F \u2286 Q).\n",
    "        \"\"\"\n",
    "\n",
    "        self.states = states                        #list\n",
    "        self.alphabet = alphabet                    #list\n",
    "        self.transitions = transitions              #dict\n",
    "        self.initial_state = initial_state          #char\n",
    "        self.final_states = final_states            #list\n",
    "\n",
    "        \"\"\"\n",
    "        states=['q0', 'q1'],\n",
    "        alphabets=['a', 'b'],\n",
    "        transitions={\n",
    "            'q0': {'a': ['q0', 'q1'], 'b': ['q1']},\n",
    "            'q1': {'a': ['q0'], 'b': ['q1', 'q0']},\n",
    "         },\n",
    "        initial_state='q0',\n",
    "        final_states=['q1']\n",
    "        \"\"\"\n",
    "\n",
    "    def is_string_valid(self, string):\n",
    "        \"\"\"Return True if string is accepted by NDFA, otherwise return False\"\"\"\n",
    "\n",
    "        inputs = list(string)\n",
    "        current_state = self.initial_state\n",
    "\n",
    "        for letter in inputs:\n",
    "\n",
    "            try:\n",
    "\n",
    "                if isinstance(current_state, list):\n",
    "                    temp_cur_state = []\n",
    "                    for state in current_state:\n",
    "                        if letter in self.transitions[state]:\n",
    "                            temp_cur_state.push(self.transitions[state][letter])\n",
    "                    current_state = temp_cur_state\n",
    "\n",
    "                elif isinstance(current_state, str):\n",
    "                    if letter in self.transitions[current_state]:\n",
    "                        current_state = self.transitions[current_state][letter]\n",
    "\n",
    "                else:\n",
    "                    return False\n",
    "\n",
    "            except KeyError as e:\n",
    "                return False\n",
    "\n",
    "        if isinstance(current_state, str):\n",
    "            if current_state in self.final_states:\n",
    "                return True\n",
    "\n",
    "        elif isinstance(current_state, list):\n",
    "            if not set(current_state).isdisjoint(self.final_states):\n",
    "                return True\n",
    "\n",
    "        return False\n",
    "\n",
    "    def convert_to_dfa(self):\n",
    "        \"\"\"\"Returns equivalent DFA of the given NDFA\"\"\"\n",
    "\n",
    "        temp_init_state_list = [self.initial_state]\n",
    "\n",
    "        foo_dict = {str(temp_init_state_list): self.transitions[self.initial_state]}\n",
    "\n",
    "        s = Stack()\n",
    "        q = Stack()\n",
    "\n",
    "        for x in self.alphabet:\n",
    "            s.push(foo_dict[str(temp_init_state_list)][x])\n",
    "\n",
    "        while not s.isEmpty():\n",
    "\n",
    "            current_states = s.pop()\n",
    "            q.push(current_states)\n",
    "\n",
    "            if current_states != foo_dict.keys():\n",
    "                foo_dict[str(current_states)] = {}\n",
    "\n",
    "            for a in self.alphabet:\n",
    "\n",
    "                temp_list = []\n",
    "\n",
    "                for c in current_states:\n",
    "\n",
    "                    try:\n",
    "                        for t in self.transitions[c][a]:\n",
    "                            if t not in temp_list:\n",
    "                                temp_list.append(t)\n",
    "\n",
    "                    except KeyError as e:\n",
    "                        pass\n",
    "\n",
    "                foo_dict[str(current_states)][a] = (temp_list)\n",
    "\n",
    "                if temp_list not in q and temp_list not in s and temp_list is not []:\n",
    "                    s.push(temp_list)\n",
    "\n",
    "        dfa_initial_state = 'Q0'\n",
    "\n",
    "        i = 0\n",
    "        map_states ={}\n",
    "        for a in foo_dict.keys():\n",
    "            map_states[a] = 'Q' + str(i)\n",
    "            i+=1\n",
    "\n",
    "        dfa_transitions = {}\n",
    "        dfa_finial_states = []\n",
    "        dfa_states = []\n",
    "\n",
    "        for a in foo_dict.keys():\n",
    "            dfa_transitions[map_states[a]] = {}\n",
    "            for b in self.alphabet:\n",
    "\n",
    "                if  set(foo_dict[a][b]).isdisjoint(self.final_states):\n",
    "                    if (a) not in dfa_finial_states:\n",
    "                        dfa_finial_states.append(map_states[a])\n",
    "\n",
    "                dfa_transitions[map_states[a]][b] = map_states[str(foo_dict[a][b])]\n",
    "\n",
    "                if map_states[a] not in dfa_states:\n",
    "                    dfa_states.append(map_states[a])\n",
    "\n",
    "                if (map_states[str(foo_dict[a][b])]) not in dfa_states:\n",
    "                    dfa_states.append(map_states[str(foo_dict[a][b])])\n",
    "\n",
    "        # Here we go\n",
    "        d = DFA(dfa_states, self.alphabet, dfa_transitions, dfa_initial_state, dfa_finial_states)\n",
    "        print(d)\n",
    "        return d\n",
    "\n",
    "    def __str__(self):\n",
    "        \"\"\"\"Pretty Print the NDFA\"\"\"\n",
    "\n",
    "        output = \"\\nNon-Deterministic Finite Automata\" + \\\n",
    "                 \"\\nStates \" + str(self.states) + \\\n",
    "                 \"\\nAlphabet \" + str(self.alphabet) + \\\n",
    "                 \"\\nTransitions \" + str(self.transitions) + \\\n",
    "                 \"\\nInital State \" + str(self.initial_state) + \\\n",
    "                 \"\\nFinal States \" + str(self.final_states)\n",
    "\n",
    "        return output\n",
    "\n",
    "\n",
    "\n",
    "d = NDFA(\n",
    "['q0', 'q1'],\n",
    "['a', 'b'],\n",
    "{\n",
    "    'q0': {'a': ['q0', 'q1'], 'b': ['q1']},\n",
    "    'q1': {'a': ['q0'], 'b': ['q1']}\n",
    " },\n",
    " 'q0',\n",
    "['q1']\n",
    ")\n",
    "\n",
    "\n",
    "\n",
    "\"\"\"\n",
    "print (d.convert_to_dfa())\n",
    "print(d.is_string_valid('a'))\n",
    "print(d)\n",
    "\"\"\""
  ],
  "/Users/Hemang/Desktop/final/automata-python/automata/language.py": [
    "class Language(object):\n",
    "    \"\"\"Basic operations that can be performed on a language\"\"\"\n",
    "\n",
    "    def __init__(self, language, alphabets, rules):\n",
    "        \"\"\"Constructor to create language and its alphabet set\"\"\"\n",
    "        if(type(language) == \"list\"):\n",
    "            self.language = language\n",
    "\n",
    "            if(type(alphabets) == \"list\"):\n",
    "                self.alphabets = alphabets\n",
    "            else:\n",
    "                self.alphabets = []\n",
    "\n",
    "            if(type(rules) == \"list\"):\n",
    "                self.rules = rules\n",
    "            else:\n",
    "                self.rules = []\n",
    "\n",
    "    def define(self, strings):\n",
    "        \"\"\"Add words to the language\"\"\"\n",
    "\n",
    "    def define_alphabets(self, element):\n",
    "        \"\"\"\"Add elements to the set of alphabets of the language\"\"\"\n",
    "\n",
    "        if(type(element) == \"list\"):\n",
    "                self.alphabet = element\n",
    "\n",
    "        else:\n",
    "            self.alphabet.push(element)\n",
    "\n",
    "    def define_rules(self, rule ):\n",
    "        \"\"\"Add rule string to python list of rules\"\"\"\n",
    "        self.rule.push(rule)\n",
    "\n",
    "    def show(self):\n",
    "        \"\"\"Getter for language\"\"\"\n",
    "        output = \"----------------\\n\"\n",
    "        output += \"Language is \" + self.language + \"\\n\\n\"\n",
    "        output += \"Alphabet for it is \" + self.alphabets + \"\\n\\n\"\n",
    "        output += \"Rules for this language are \" + self.rules + \"\\n\"\n",
    "        output += \"\\n----------------\"\n",
    "        return output\n",
    "\n",
    "    def show_alphabet(self):\n",
    "        \"\"\"Getter for alphabets\"\"\"\n",
    "        return self.alphabets\n"
  ],
  "/Users/Hemang/Desktop/final/automata-python/automata/testing.py": [
    "l = [1,2,3]\n",
    "p = [1,2,3]\n",
    "\n",
    "if l==p:\n",
    "    print (\"H\")"
  ]
}